<p id="f-777-custom-generic-functions-md"></p>
<h1>More About generic functions and methods of generic types</h1>

<h2>The type of a value used in a generic function must be either a specified type parameter, or a specified ordinary type</h2>

<p>Go custom generics are not implemented as simple code text templates.
This is a principal differece from code generation.
Every expression used in a generic function must have a specified type,
which is either an ordinary type, or a type parameter.</p>

<p>For example, in the following code snippet, the functions <code>foo</code> and <code>bar</code> both compile okay,
but the function <code>dot</code> fails to compile. The reason is simple:</p>

<ul>
<li>in the function <code>foo</code>, the type of <code>x</code> is <code>T</code>, which is a type parameter.
Certainly, in uses if the function, <code>x</code> might be instantiated as <code>int</code> or <code>string</code>,
but which doesn't change the fact that, from the view of compilers,
its type is a type parameter.</li>
<li>in the function <code>bar</code>, the type of <code>x[1]</code> is a specified ordinary type, <code>int</code>.</li>
<li>in the function <code>dot</code>, the type of <code>x[1]</code> might be <code>int</code> or <code>string</code>.
In the function, there is only one type parameter, <code>T</code>, which is surely not the type of <code>x[1]</code>.</li>
</ul>

<pre><code class="language-Go">func foo[T int|string](x T) {
	_ = x // okay
}

func bar[T [2]int|[8]int](x T) {
	_ = x[1] // okay
}

func dot[T [2]int|[2]string](x T) {
	_ = x[1] // error: invalid operation: cannot index x
}
</code></pre>

<p>For the same reason, in the following code snippet,
the functions <code>nop</code> and <code>jam</code> both compile okay,
but the function <code>mud</code> doesn't.</p>

<pre><code class="language-Go">func nop[T *Base, Base int32|int64](x T) {
	_ = *x // okay
}

func jam[T int32|int64](x *T) {
	_ = *x // okay
}

func mud[T *int32|*int64](x T) {
	_ = *x // error: invalid operation
}
</code></pre>

<p>The same, in the following code snippet, only the function <code>box</code> fails to compile,
all the others compile okay.</p>

<pre><code class="language-Go">func box[T chan int | chan byte](c T) {
	_ = &lt;-c // error: no core type
}


func sed[T chan E, E int | byte](c T) {
	_ = &lt;-c // okay
}

type Ch &lt;-chan int
func win[T chan int | Ch](c T) {
	_ = &lt;-c // okay
}

func cat[T []E, E any](c T, i int) () {
	_ = c[i] // okay
}
</code></pre>

<p>The rule talked about in this section is just a general rule.
For some operations, some extra restrictions might be applied.
Often, the extra restrictions are core types and specific types related.</p>

<h2>Type declarations inside generic functions are not allowed now (Go 1.18)</h2>

<pre><code class="language-Go">func foo[T any]() {
	type MyByte byte // error
}

type T[_ any] struct{}

func (T[_]) bar() {
	type MyInt int // error
}
</code></pre>

<p><a href="https://golang.org/issue/47631">https://golang.org/issue/47631</a></p>

<h2>Type parameters of constraints with empty type sets</h2>

<p>could not be instantiated, but it compiles okay.</p>

<h2>const types can't be type parameter</h2>

<p>func f[P int]() {
	const y P = 5 //
}</p>

<p>func g[P int]() {
	const _ = P(5) //
}</p>

<p><a href="https://github.com/golang/go/issues/50202#issuecomment-1033369747">https://github.com/golang/go/issues/50202#issuecomment-1033369747</a></p>

<p>Converting a constant to a type parameter yields a non-constant value of
the argument pased to the type parameter.</p>

<pre><code class="language-Go">package main

const S = &quot;Go&quot;

func f() byte {
	return 64 &lt;&lt; len(string(S)) &gt;&gt; len(string(S))
}

func g[T string]() byte {
	return 64 &lt;&lt; len(T(S)) &gt;&gt; len(T(S))
}

func main() {
	println(f(), g())
}
</code></pre>

<h2>local type declarations in generic code don't work</h2>

<p><a href="https://github.com/golang/go/issues/47631">https://github.com/golang/go/issues/47631</a></p>

<h2>no generic method, use alternative</h2>

<p><a href="https://github.com/golang/go/issues/49085">https://github.com/golang/go/issues/49085</a></p>

<p><a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#methods-may-not-take-additional-type-arguments">https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#methods-may-not-take-additional-type-arguments</a></p>

<p>This will make code even more cubersome.
And make <code>reflect.Method</code> ...</p>

<h2>Type parameters act</h2>

<p><a href="https://github.com/golang/go/issues/50421">https://github.com/golang/go/issues/50421</a></p>

<pre><code class="language-Go">func toString[T byte|rune](slice []T) string {
   return string(slice) // cannot convert slice (variable of type []T) to type string
}

func toString[T []byte|[]rune](slice T) string {
        return string(slice) // okay
}

func toString[T []E, E byte|rune](slice T) string {
        return string(slice) // cannot convert []E (in T) to string
}
</code></pre>

<h2>There are no predeclared <code>assignableTo</code> and <code>assignableFrom</code> constraints</h2>

<h2>There are no predeclared <code>convertibleTo</code> and <code>convertibleFrom</code> constraints</h2>

<p>Whether or not a conversion involving type parameters is legal is determined
by the specific type sets of the constraints (at most two) of involving type parameters.</p>

<p>unspecific conversions are not supported, there are not the <code>convertibleFrom</code> and <code>convertibleTo</code> constraints.</p>

<pre><code class="language-Go">func Convert[From, To any](in []From, f func(From) To) []To {
	var out = make([]To, len(in))
	for i := range in {
		out[i] = f(in[i])
	}
	return out
}
</code></pre>

<pre><code class="language-Go">func foo[T int](x *T) *int {
	// cannot convert x (variable of type *T) to type *int
	return (*int)(x)
}

</code></pre>

<pre><code class="language-Go">func foo[T string](x T) string  {
	return x // error
}

func bar[T []byte](x T) []byte {
	return x // okay
}
</code></pre>

<pre><code class="language-Go">func f[A, B int](x A, y B){
	x = y // error
	y = x // error
}
</code></pre>

<p>It is worth making this valid. Maybe later</p>

<p>The current constraint design lacks of two abilities:
1. The ability of specifying a type argument must be an interface type.
2. The ability of specifying a type argument must not be an interface type.</p>

<p><a href="https://groups.google.com/g/golang-nuts/c/EL6A2jFa92k">https://groups.google.com/g/golang-nuts/c/EL6A2jFa92k</a></p>

<p><a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#no-way-to-express-convertibility">https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#no-way-to-express-convertibility</a></p>

<p><a href="https://gophers.slack.com/archives/C88U9BFDZ/p1647950715616299">https://gophers.slack.com/archives/C88U9BFDZ/p1647950715616299</a></p>

<pre><code class="language-Go">// ConvertSlice converts each element of the slice
// as to the type To by doing a dynamic type conversion.
// Any elements of as that don't implement To will be
// omitted from the returned slice.
func ConvertSlice[To, From any](as []From) []To {
	bs := make([]To, 0, len(as))
	for _, a := range as {
		if b, ok := any(a).(To); ok {
			bs = append(bs, b)
		}
	}
	return bs
}
</code></pre>

<p>##</p>

<pre><code class="language-Go">func f[A, B ~int](x A, y B){
	x = A(y)
	y = B(x)
}

func g[A, B int](x *A, y *B){
	x = (*A)(y) // error: cannot convert y
	y = (*B)(x) // error: cannot convert x
}
</code></pre>

<p><a href="https://github.com/golang/go/issues/50815">https://github.com/golang/go/issues/50815</a> pointer convert
<a href="https://github.com/golang/go/issues/51501">https://github.com/golang/go/issues/51501</a> single type ...</p>

<h2>Calls to predeclared functions</h2>

<h2>len, cap</h2>

<h2>Calls to the built-in <code>len</code> and <code>cap</code> functions with arguments of array type parameters always return non-constant results</h2>

<p>For example, currently (Go 1.18), the first <code>cap</code> and <code>len</code> calls in the following code fail to compile.</p>

<pre><code class="language-Go">func f[T [2]int]() {
	var x T
	const _ = cap(x) // error: cap(x) is not constant
	const _ = len(x) // error: len(x) is not constant

	var _ = cap(x) // okay
	var _ = len(x) // okay
	
	var y [2]int
	const _ = cap(y) // okay
	const _ = len(y) // okay
}
</code></pre>

<p>Similarly, calls to the built-in <code>len</code> and <code>cap</code> functions with arguments of array pointer type parameter also always return non-constant results.</p>

<pre><code class="language-Go">func g[T *[2]int]() {
	var x T
	const _ = cap(x) // error: cap(x) is not constant
	const _ = len(x) // error: len(x) is not constant
}
</code></pre>

<p>This might be never changed in future Go versions: <a href="https://github.com/golang/go/issues/50226">https://github.com/golang/go/issues/50226</a></p>

<h2>The built-in <code>len</code> and <code>cap</code> functions don't accept arguments of array pointer types whose base types are array type parameters</h2>

<p>For example, currently (Go 1.18), the following function doesn't compile.</p>

<pre><code class="language-Go">func h[T [2]int]() {
	var x T
	var _ = len(&amp;x) // invalid argument: &amp;x (value of type *T) for len
	var _ = cap(&amp;x) // invalid argument: &amp;x (value of type *T) for cap
}
</code></pre>

<p>The restriction might be removed in future Go versions, or not, I'm nor sure.</p>

<h2>make</h2>

<h2>delete</h2>

<h2>close</h2>

<h2>A call to the built-in <code>close</code> function requires its argument has specific types and all the specific types are channels</h2>

<h2>A call to the built-in <code>delete</code> function requires its argument has specific types and all the specific types are maps with identical key types</h2>

<h3>Calles to predeclared <code>complex</code>, <code>real</code> and <code>imag</code> functions don't accept arguments of type parameter types</h3>

<p><a href="https://github.com/golang/go/issues/50937">https://github.com/golang/go/issues/50937</a></p>

<pre><code class="language-Go">func Real[T complex64](s T) float32 {
	return real(s)
}
</code></pre>

<h2>An element index operation require the container operand's specific types may not include maps and non-maps at the same time</h2>

<p>And if all specific types are maps, them their underlying types must be identical;
Otherwise, their element types must be identical.
The elements of strings are viewed as <code>byte</code> values.</p>

<p>For example, currently (Go 1.18), in the following code snippet, only the functions <code>foo</code> and <code>tup</code> compile okay.</p>

<pre><code class="language-Go">func foo[T []int | [2]int](c T) {
	_ = c[0] // okay
}

func bar[T []int | map[int]int](c T) {
	_ = c[0] // invalid operation: cannot index c
}

func vet[T map[string]int | map[int]int](c T) {
	_ = c[0] // invalid operation: cannot index c
}

func six[T map[string]int | map[int]int](c T) {
	_ = c[0] // invalid operation: cannot index c
}

type Map map[int]string
func tup[T map[int]string | Map](c T) {
	_ = c[0] // okay
}
</code></pre>

<h2>A (sub)slice operation requires the container operand has a core type</h2>

<p>For example, currently (Go 1.18), the following function fails to compile.</p>

<pre><code class="language-Go">func foo[T []int | [2]int](c T) {
	_ = c[:] // invalid operation: cannot slice c: T has no core type
}
</code></pre>

<p>There is an exception for this rule. If the container operand's specific types
only include string and byte slice types, then it is not required to have a core type.
For example, the following function compiles okay.</p>

<pre><code class="language-Go">func bar[T string | []byte](c T) {
	_ = c[:] // okay
}
</code></pre>

<h2>A call to the built-in <code>make</code> function requires its first argument (container type) has a core type</h2>

<p>Currently (Go 1.18), in the following code snippet, the functions <code>foo</code> and <code>bar1</code> both
fail to compiler, the other two compile okay.
The reason is the first argument of a call to the built-in <code>make</code> function
is required to have a core type.
Neither of the <code>foo</code> and <code>bar1</code> functions satisfies this requirement,
whereas both of the other two functions satisfy this requirement.</p>

<pre><code class="language-Go">func foo[T chan bool | chan int]() {
	_ = make(T) // error: invalid argument: no core type
}

func bar1[T chan&lt;- int | &lt;-chan int]() {
	_ = make(T) // error: invalid argument: no core type
}

type Stream chan int
type Queue Stream

func bar2[T Stream | chan int | Queue | chan&lt;- int]() {
	_ = make(T) // okay
}

func bar3[T Stream | chan int | Queue | &lt;-chan int]() {
	_ = make(T) // okay
}
</code></pre>

<p>By my understanding, this requirement is in order to make subsequent operations
on the made containers (they are channels in the above example) always legal.
For example, to prevent make sure a value received from the made
channel has a specified type (either a type parameter, or an ordinary type).</p>

<p>Personally, I think the requirement is over strict.
After all, the assumed subsequent operations might not happen for many use cases
(such as he functions <code>foo_a</code> and <code>bar1_a</code> below), and the containers may present as (value) parameters
even if it has not a core type, as the following example shows:</p>

<pre><code class="language-Go">func g(any) {}

func foo_a[T chan bool | chan int](x T) {
	g(x)
}

func bar1_a[T chan&lt;- int | &lt;-chan int](x T) {
	g(x)
}
</code></pre>

<p>Because of the same requirement, neither of the following three functions compile.</p>

<pre><code class="language-Go">func zig[T ~[]int | map[int]int](c T) {
	_ = make(T) // error: invalid argument: no core type
}

func fat[T ~[]int | ~[]bool](c T) {
	_ = make(T) // error: invalid argument: no core type
}
</code></pre>

<p>Calls to the built-in <code>new</code> function have not this requirement.</p>

<h2>The type literal in a composite literal must have a core type</h2>

<p>This restriciton is smimilar to the last one.
For example, currently (Go 1.18), in the following code snippet,
the functions <code>foo</code> and <code>bar</code> compile okay,
but the other ones don't.</p>

<pre><code class="language-Go">func foo[T ~[]int] () {
	_ = T{}
}

type Ints []int

func bar[T []int | Ints] () {
	_ = T{}
}

func ken[T []int | []string] () {
	_ = T{} // error: invalid composite literal type T
}

func jup[T [2]int | map[int]int] () {
	_ = T{} // error: invalid composite literal type T
}
</code></pre>

<h2>In a <code>for-range</code> loop, the ranged container is required to have a core type</h2>

<p>For example, currently (Go 1.18), in the following code,
only the last two functions, <code>dot1</code> and <code>dot2</code> compile okay.</p>

<pre><code class="language-Go">func values[T []E | map[int]E, E any](kvs T) []E {
	r := make([]E, 0, len(kvs))
	for _, v := range kvs { // cannot range over kvs (T has no core type)
		r = append(r, v)
	}
	return r
}

func keys[T map[int]string | map[int]int](kvs T) []int {
	r := make([]int, 0, len(kvs))
	for k := range kvs { // cannot range over kvs (T has no core type)
		r = append(r, k)
	}
	return r
}

func sum[M map[int]int | map[string]int](m M) (sum int) {
	for _, v := range m {
		sum += v
	}
	return
}

func foo[T []int | []string] (v T) {
	for range v {} // error: cannot range over v (T has no core type)
}

func bar[T [3]int | [6]int] (v T) {
	for range v {} // error: cannot range over v (T has no core type)
}

type MyInt int

func cat[T []int | []MyInt] (v T) {
	for range v {} // error: cannot range over v (T has no core type)
}

type Slice []int

func dot1[T []int | Slice] (v T) {
	for range v {} // okay
}

func dot2[T ~[]int] (v T) {
	for range v {} // okay
}
</code></pre>

<p>Need a cire type.</p>

<pre><code class="language-Go">func f[T []int | map[int]int] (t T, g func(int)) {
	for _, v := range t { // error
	g(v)
	}
}
</code></pre>

<p>The restriction is intended. I think its intention is to ensure both of the two iteration variables
always have a specified type (either an ordinary type or a type parameter type).
Howwver, this restriction is over strict for this intention.
Becease, in practice, the key types or element types of some containers are identical,
even if the underlying type of the containers are different.
And in many use cases, either of the two iteration variables is ignored.</p>

<p>I'm not sure whether or not the restriction will be removed in future Go versions: <a href="https://github.com/golang/go/issues/49551">https://github.com/golang/go/issues/49551</a>.
In my opinion, the restriciton reduces the usefulness of Go custom generics in some extent.</p>

<p>If all possible types are slice and arrays, and their element types are identical,
we could use plan <code>for</code> loops to walk around this restriction.</p>

<pre><code class="language-Go">func cat[T [3]int | [6]int | []int] (v T) {
	for i := 0; i &lt; len(v); i++ { // okay
		_ = v[i] // okay
	}
}
</code></pre>

<p>The following code also doesn't compile, but which is reasonable.
Because the iterated elements for <code>string</code> are <code>rune</code> values,
whereas the iterated elements for <code>[]byte</code> are <code>byte</code> values.</p>

<pre><code class="language-Go">func mud[T string | []byte] (v T) {
	for range v {} // error: cannot range over v (T has no core type)
}
</code></pre>

<p>If it is intended to iterate the bytes in either byte slices and strings,
we could use the following code to achieve the goal.</p>

<pre><code class="language-Go">func mud[T string | []byte] (v T) {
	for range []byte(v) {} // okay
}
</code></pre>

<p>The conversion <code>[]byte(v)</code> (if it follows the <code>range</code> keyword) is specifically
optimization by the official standard Go compiler so that it doesn't duplicate
underlying bytes.</p>

<p>The following code doesn't compile now (Go 1.18).
Whether or not it will compile later is unknown.</p>

<pre><code class="language-Go">func PrintEach[T string | []rune](runes T) {
	for _, r := range runes { // cannot range over runes
		_ = r
	}
}
</code></pre>

<h2>A function is required to have a core type to be callable</h2>

<p>For example, currently (Go 1.18), in the following code, the functions <code>foo</code> and <code>bar</code> don't compile,
bit the <code>dot</code> function does.</p>

<pre><code class="language-Go">func foo[F func(int) | func(any)] (f F) {
	f(1) // error: invalid operation: cannot call non-function f
}

func bar[F func(int) | func(int)int] (f F) {
	f(1) // error: invalid operation: cannot call non-function f
}

type Fun func(int)

func dot[F func(int) | Fun] (f F) {
	f(1) // okay
}
</code></pre>

<p>Not sure whether or not the restriction will be lifted in future Go versions.</p>

<h2>Compile-time type switch</h2>

<p><a href="https://github.com/golang/go/issues/45380#issuecomment-1074153465">https://github.com/golang/go/issues/45380#issuecomment-1074153465</a></p>
