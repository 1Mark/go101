<p id="f-557-md"></p>
<h2>How to interpret constraints</h2>

<pre><code class="language-Go">type ReadWriter interface { io.Reader; io.Writer }
</code></pre>

<p>It requires type arguments:</p>

<ul>
<li>must satisi</li>
</ul>

<p>It determines type parameters:</p>

<ul>
<li>has a <code>Read</code> method</li>
<li>has a <code>Write</code> method</li>
</ul>

<h2>Type parameters in methods could even be <code>_</code> if they are not used in the method declaration</h2>

<h2>Try to use aliases of instantiated types</h2>

<p>Or embed them, to make the methods declared for them available.</p>

<p>This is actually the same as general value types, nothing special.</p>

<pre><code class="language-Go">package main

type Foo[T any] []T

func (f Foo[T]) M() {}

type (
	P = Foo[int]
	Q Foo[int]
	R struct{
		Foo[int]
	}
)

func main() {
	var x P
	x.M() // okay
	
	var y Q
	y.M() // y.M undefined (type Q has no field or method M)
	
	var r R
	r.M() // okay
}
</code></pre>
