<p id="f-555-type-constraints-and-parameters-md"></p>
<h1>Constraints and Type Parameters</h1>

<p>A constraint means a type constraint, it is used to constrained some type parameters.
We could view constraints as types of types.</p>

<p>The relation between a constraint and a type parameter is like
the relation between a type and a value.
If we say types are value templates (and values are type instances),
then constraints are type templates (and types are constraint instances).</p>

<p>A type parameter is a type which is declared in a type parameter list
and could be used in a generic type specification or a generic function/method declaration.
Each type parameter is a distinct named type.</p>

<p>Since Go 1.18, value types in Go could be categorized in two categories:</p>

<ul>
<li>type parameter types: the types declared in type parameter lists.</li>
<li>ordinary types: the types not declared in type parameter lists.
Before Go 1.18, there are only ordinary types.</li>
</ul>

<p>Type parameter lists will be explained in detail in a later section.</p>

<p>As mentioned in the previous chapter, type constraints are actually
<a href="https://go101.org/article/interface.html">interface types</a>.
In order to let interface types be competent to act as the constraint role,
Go 1.18 enhances the expressiveness of interface types by supporting several new notations.</p>

<h2>Enhanced interface syntax</h2>

<p>Some new notations are introduced into Go to make it is possible to use interface types as constraints.</p>

<ul>
<li>The <code>~T</code> form, where <code>T</code> is a type literal or type name.
<code>T</code> must denote a non-interface type whose underlying type is itself
(so <code>T</code> may not be a type parameter, which is explained below).
The form denotes a type set, which include all types whose
<a href="https://go101.org/article/type-system-overview.html#underlying-type">underlying type</a> is <code>T</code>.
The <code>~T</code> form is called a tilde form or type tilde in this book
(or underlying term and approximation type elsewhere).</li>
<li>The <code>T1 | T2 | ... | Tn</code> form, which is called a union of terms (or type/term union in this book).
Each <code>Tx</code> term is a tilde form, type literal, or type name,
and it may not denote a type parameter.
There are some restrictions of using union terms.
These restrictions will be described in a section below.</li>
</ul>

<p>Note that, a type literal always denotes an unnamed type,
whereas a type name may denote a named type or unnamed type.</p>

<p>Some legal examples of the new notations:</p>

<pre><code class="language-Go">// tilde forms
~int
~[]byte
~map[int]string
~chan struct{}
~struct{x int}

// unions of terms
uint8 | uint16 | uint32 | uint64
~[]byte | ~string
map[int]int | []int | [16]int | any
chan struct{} | ~struct{x int}
</code></pre>

<p>We know that, before Go 1.18, an interface type may embed</p>

<ul>
<li>arbitrary number of method specifications (method elements, one kind of interface elements);</li>
<li>arbitrary number of type names (type elements, the other kind of interface elements),
but the type names must denote interface types.</li>
</ul>

<p>Go 1.18 relaxed the limitations of type elements, so that now an interface type
may embed the following type elements:</p>

<ul>
<li>any type literals or type names, whether or not they denote interface types, but they must not denote type parameters.</li>
<li>tilde forms.</li>
<li>term unions.</li>
</ul>

<p>The orders of interface elements embedded in an interface type are not important.</p>

<p>The following code snippet shows some interface type declarations,
in which the interface type literals in the declarations of <code>N</code> and <code>O</code>
are only legal since Go 1.18.</p>

<pre><code class="language-Go">type L interface {
	Run() error
	Stop()
}

type M interface {
	L
	Step() error
}

type N interface {
	M
	interface{ Resume() }
	~map[int]bool
	~[]byte | string
}

type O interface {
	Pause()
	N
	string
	int64 | ~chan int | any
}
</code></pre>

<p>Embedding an interface type in another one is equivalent to (recursively) expanding the elements in the former into the latter. In the above example, the declarations of <code>M</code>, <code>N</code> and <code>O</code> are equivalent to the following ones:</p>

<pre><code class="language-Go">type M interface {
	Run() error
	Stop()
	Step() error
}

type N interface {
	Run() error
	Stop()
	Step() error
	Resume()
	~map[int]bool
	~[]byte | string
}

type O interface {
	Run() error
	Stop()
	Step() error
	Pause()
	Resume()
	~map[int]bool
	~[]byte | string
	string
	int64 | ~chan int | any
}
</code></pre>

<p>We could view a single type literal, type name or tilde form as a term union with only one term.
So simply speaking, since Go 118, an interface type may specify some methods and embed some term unions.</p>

<p>An interface type without any embedding elements is called an empty interface.
For example, the predeclared <code>any</code> type alias denotes an empty interface type.</p>

<h2>Type sets and method sets</h2>

<p>Before Go 1.18, an interface type is defined as a method set.
Since Go 1.18, an interface type is defined as a type set.
A type set only consists of non-interface types.</p>

<ul>
<li>The type set of a non-interface type literal or type name only contains the type denoted by the type literal or type name.</li>
<li>As just mentioned above, the type set of a tilde form <code>~T</code> is the set of types whose underlying types are <code>T</code>. In theory, this is an infinite set.</li>
<li>The type set of a method specification is the set of non-interface types whose method sets include the method specification.
In theory, this is an infinite set.</li>
<li>The type set of an empty interface is the set of all non-interface types.
In theory, this is an infinite set.</li>
<li>The type set of a union of terms <code>T1 | T2 | ... | Tn</code> is the union of the type sets of the terms.</li>
<li>The type set of a non-empty interface is the intersection of the type sets of its interface elements.</li>
</ul>

<p>As the type set of an empty interface type contains all non-interface types.
It is a super set of any type set.</p>

<p>By the current specification,
two unnamed constraints are equivalent to each other if their type sets are equal.</p>

<p>Given the types declared in the following code snippet,
for each interface type, its type set is shown in its preceding comment.</p>

<pre><code class="language-Go">type Bytes []byte  // underlying type is []byte
type Letters Bytes // underlying type is []byte
type Blank struct{}
type MyString string // underlying type is string

func (MyString) M() {}
func (Bytes) M() {}
func (Blank) M() {}

// The type set of P only contians one type:
// []byte.
type P interface {[]byte}

// The type set of Q contains
// []bytes, Bytes, and Letters.
type Q interface {~[]byte}

// The type set of R contains only two types:
// []byte and string.
type R interface {[]byte | string}

// The type set of S is empty.
type S interface {R; M()}

// The type set of T contains:
// []byte, Bytes, Letters, string, and MyString.
type T interface {~[]byte | ~string}

// The type set of U contains:
// MyString, Bytes, and Blank.
type U interface {M()}

// V &lt;=&gt; P
type V interface {[]byte; any}

// The type set of W contains:
// Bytes and MyString.
type W interface {T; U}

// Z &lt;=&gt; any. Z is a blank interface. Its
// type set contains all interface types.
type Z interface {~[]byte | ~string | any}
</code></pre>

<p>Please note that interface elements are separated with semicolon (<code>;</code>),
either explicitly or implicitly (Go compilers will
<a href="https://go101.org/article/line-break-rules.html">insert some missing semicolons as needed in compilations</a>).
The following interface type literals are equivalent to each other.
The type set of the interface type denoted by them is empty.
The interface type and the underlying type of the type <code>S</code>
shown in the above code snippet are actually identical.</p>

<pre><code class="language-Go">interface {~string; string; M();}
interface {~string; string; M()}
interface {
	~string
	string
	M()
}
</code></pre>

<p>If the type set of a type <code>X</code> is a subset of an interface type <code>Y</code>,
we say <code>X</code> implements (or satisfies) <code>Y</code>.
Here, <code>X</code> may be an interface type or a non-interface type.</p>

<p>Because the type set of an empty interface type is a super set of the type sets of any types,
all types implement an empty interface type.</p>

<p>In the above example,</p>

<ul>
<li>the interface type <code>S</code>, whose type set is empty, implements all interface types.</li>
<li>all types implement the interface type <code>Z</code>, which is actually a blank interface type.</li>
</ul>

<p>The list of methods specified by an interface type is called the method set of the interface type.
If an interface type <code>X</code> implements another interface type <code>Y</code>, then the method set of <code>X</code> must be a super set of <code>Y</code>.</p>

<p>Interface types whose type sets can be defined entirely by a method set (may be empty)
are called basic interface types.
Before 1.18, Go only supports basic interface types.
Basic interfaces may be used as either value types or type constraints,
but non-basic interfaces may only be used as type constraints (as of Go 1.18).</p>

<p>In the above examples, <code>L</code>, <code>M</code>, <code>U</code>, <code>Z</code> and <code>any</code> are basic types.</p>

<p>In the following code, the declaration lines for <code>x</code> and <code>y</code> both compile okay,
but the line declaring <code>z</code> fails to compile.</p>

<pre><code class="language-Go">var x any
var y interface {M()}

// error: interface contains type constraints
var z interface {~[]byte}
</code></pre>

<p>Using non-baisc interface types as value types might be supported in future Go versions.</p>

<p>BTW, currently (Go 1.18), there is an unintended restriction: non-basic interface types may not be aliased.
For example, the following type alias declarations are illegal:</p>

<pre><code class="language-Go">type C[T any] interface{~int; M() T}
type C1 = C[bool]
type C2 = comparable
type C3 = interface {~[]byte | ~string}
</code></pre>

<p>Whereas the following ones are legal:</p>

<pre><code class="language-Go">type Ca = any
type Cb = interface{M1(); M2() int}
</code></pre>

<p>The unintended restriction <a href="https://github.com/golang/go/issues/51616">will be removed in Go 1.19</a>.</p>

<h2>More about the predeclared <code>comparable</code> constraint</h2>

<p>As aforementioned, besides <code>any</code>, Go 1.18 introduces another new predeclared identifier <code>comparable</code>,
which denotes an interface type that is implemented by all comparable types.</p>

<p>The <code>comparable</code> interface type could be embedded in other interface types
to filter out incomparable types from their type sets.
For example, the type set of the following declared constraint <code>C</code> contains only one type: <code>string</code>.</p>

<pre><code class="language-Go">type C interface {
	comparable
	[]byte | string | func() | map[int]bool
}
</code></pre>

<p>Currently (Go 1.18), the <code>comparable</code> interface is treated as a non-basic interface type.
So, now, it may only be used as type parameter constraints, not as value types.
The following code is illegal:</p>

<pre><code class="language-Go">var x comparable = 123
</code></pre>

<p>The type set of the <code>comparable</code> interface is the set of all comparable types.
The set is a subset of the type set of the <code>any</code> interface,
so <code>comparable</code> undoubtedly implements <code>any</code>, and not vice versa.</p>

<p>On the other hand, starting from Go 1.0, all basic interface types are treated as comparable types.
The blank interface type <code>any</code> is not an exception.
So it looks that <code>any</code> (as a value type) should satisfy (implement) the <code>comparable</code> constraint.
This is quite odd.</p>

<p>After deliberation, Go core team believe that
<a href="https://github.com/golang/go/issues/50646#issuecomment-1023706545">it is a design flaw</a>
to treat all interface types as comparable types and it is a pity that
the <code>comparable</code> type has not been supported since Go 1.0 to avoid this flaw.</p>

<p>Go core team try to make up for this flaw in Go custom generics age.
So they decided that all basic interface types don't satisfy (implement) the <code>comparable</code> constraint.
A consequence of this decision is <a href="https://github.com/golang/go/issues/51257">it causes diffculties to some code designs</a>.</p>

<p>To avoid the consequence, a proposal has been made to
<a href="https://github.com/golang/go/issues/51338">permit using <code>comparable</code> as value types</a>.
Whether or not it should be accepted is still under discuss.
It could be accepted in as earlier as Go 1.19.</p>

<p>Another benefit brought by the proposal is that it provides a way to
ensure some interface comparisons will never panic.
For example, calls to the following function might panic at run time:</p>

<pre><code class="language-Go">func foo(x, y any) bool {
	return x == y
}

var _ = foo([]int{}, []int{}) // panics
</code></pre>

<p>If the <code>comparable</code> type could be used as a value type,
then we could change the parameter types of the <code>foo</code> function
to <code>comparable</code> to ensure the calls to the <code>foo</code> function will never panic.</p>

<pre><code class="language-Go">func foo(x, y comparable) bool {
	return x == y
}

var _ = foo([]int{}, []int{}) // fails to compile
</code></pre>

<h2>Some restrictions of using union terms</h2>

<p>The above has mentioned that a union term may not be a type parameter. There are two other restrictions.</p>

<p>The first is an implementation specific restriction: a term union with more than one term cannot contain the predeclared identifier <code>comparable</code> or interfaces that have methods.
For example, the following term unions are both illegal (as of Go toolchain 1.18):</p>

<pre><code class="language-Go">[]byte | comparable
string | error
</code></pre>

<p>Another restriction is that the type sets of all non-interface type terms in a term union must have  no intersections.
Interface type terms have no this restriction, but the current implementation (Go toolchain 1.18) disallows identical interface type terms. For example, in the following code snippet, the term unions in the first two type declarations fail to compile, but the last two compile okay.</p>

<pre><code class="language-Go">type _ interface {
	int | ~int // error
}

type _ interface {
	interface{int} | interface{int} | interface{~int} // error
}

type _ interface {
	interface{int} | interface{~int} // okay
}

type _ interface {
	int | interface{~int} // okay
}
</code></pre>

<p>The four term unions in the above code snippet are equivalent to each other in logic,
which means this restriction is not very reasonable.
So it might be removed in later Go versions, of become stricter to defeat the workaround.</p>

<h2>Type parameter lists</h2>

<p>From the examples shown in the last chapter, we know type parameter lists
are used in generic type specifications, method declarations for generic base types
and generic function declarations.</p>

<p>A type parameter list contains at least one type parameter declaration
and is enclosed in square brackets.
Each parameter declaration is composed of a name part and a constraint part
(we can think the constraints are implicit in method declarations for generic base types).
Parameter declarations are comma-separated in a type parameter list.</p>

<p>In a type parameter list, all type parameter names must be present.
They may be the blank identifier <code>_</code> (called blank name).
All non-blank names in a type parameter list must be unique.</p>

<p>Similar to value parameter lists, if the constraints of
some successive type parameter declarations in a type parameter list are identical,
then these type parameter declarations could share a common
constraint part in the type parameter list.
For example, the following two type parameter lists are equivalent.</p>

<pre><code class="language-Go">[A any, B any, X comparable, _ comparable]
[A, B any, X, _ comparable]
</code></pre>

<p>Similar to value parameter lists, if the right <code>]</code> token in a type parameter list
and the last constraint in the list are at the same line, an optional comma is allowed
to be inserted between them.
<a href="https://go101.org/article/line-break-rules.html#commas">The comma is required</a> if the two are not at the same line.</p>

<p>For example, in the following code, the beginning lines are legal, the ending lines are not.</p>

<pre><code class="language-Go">// Legal ones:
[T interface{~map[int]string}]
[T interface{~map[int]string},]
[T interface{~map[int]string},
]
[A, B any, _, _ comparable]
[A, B any, _, _ comparable,]
[A, B any, _, _ comparable,
]
[A, B any,
_, _ comparable]

// Illegal ones:
[A, B any, _, _ comparable
]
[T interface{~map[int]string}
]
</code></pre>

<p>Variadic type parameters are not supported.</p>

<h2>Simplified constraint form</h2>

<p>In a type parameter list, if a constraint only contains one element
and that element is a type element,
then the enclosing <code>interface{}</code> may be omitted for convenience.
For example, the following two type parameter lists are equivalent.</p>

<pre><code class="language-Go">[X interface{string|[]byte}, Y interface{~int}]
[X string|[]byte, Y ~int]
</code></pre>

<p>The simplified constraint forms make code look much cleaner.
For most cases, they don't cause any problems.
However, it might cause parsing ambiguities for some special cases.
In particular, parsing ambiguities might arise when the type parameter list
of a generic type specification declares a single type parameter
which constraint presents in simplified form and starts with <code>*</code> or <code>(</code>.</p>

<p>For example, does the following code declare a generic type?</p>

<pre><code class="language-Go">type G[T *int] struct{}
</code></pre>

<p>It depends on what the <code>int</code> identifier denotes.
If it denotes a type (very possible, not absolutely),
then compilers should think the code declares a generic type.
If it denotes a constant (it is possible), then compilers
will treat <code>T *int</code> as a multiplication expression and
think the code declares an ordinary array type.</p>

<p>It is possible for compilers to distinguish what the <code>int</code> identifier denotes,
but there are some costs to achieve this. To avoid the costs,
compilers always treat the <code>int</code> identifier as a value expression
and think the above declaration is an ordinary array type declaration.
So the above declaration line will fail to compile
if <code>T</code> or <code>int</code> don't denote integer constants.</p>

<p>Then how to declare a generic type with a single type parameter with <code>*int</code> as the constraint?
There are two ways to accomplish this:</p>

<ol>
<li>use the full constraint form, or</li>
<li>let a comma follow the simplified constraint form.</li>
</ol>

<p>The two ways are shown in the following code snippet:</p>

<pre><code class="language-Go">// Assume int is a predeclared type.
type G[T interface{*int}] struct{}
type G[T *int,] struct{}
</code></pre>

<p>The two ways shown above are also helpful for
some other special cases which might also cause parsing ambiguities.
For example,</p>

<pre><code class="language-Go">// PA might be array pointer variable, or a type name.
// Compilers don't treat it as a type name.
type K[cap (*PA)] struct{}

// S might be a string constant, or a type name.
// Compilers don't treat it as a type name.
type L[len (S)] struct{}
</code></pre>

<p>The following is another case which might cause parsing ambiguity.</p>

<pre><code class="language-Go">// T, int and bool might be three constant integers,
// or int and bool are both predeclared types.
type C5[T *int|bool] struct{}
</code></pre>

<p>As of Go toolchain 1.18, inserting a comma after the presumed constraint <code>*int|bool</code> doesn't work
(It is <a href="https://github.com/golang/go/issues/51488">a bug</a>
in Go toolchain 1.18 and will be fixed in Go toolchain 1.19).</p>

<p>Now, we could use full constraint form or exchange the places of <code>*int</code> and <code>bool</code> to make it compile okay.</p>

<pre><code class="language-Go">// Assume int and bool are predeclared types.
type C5[T interface{*int|bool}] struct{}
type C5[T bool|*int] struct{}
</code></pre>

<p>On the other hand, the following two weird generic type declarations are both legal.</p>

<pre><code class="language-Go">// &quot;make&quot; is a declared type parameter.
// Its constraint is interface{chan int}.
type PtrToChan[make (chan int)] *make

// &quot;new&quot; is a declared type parameter.
// Its constraint is interface{[3]float64}.
type Matrix33[new ([3]float64)] [3]new
</code></pre>

<p>The two declarations are really bad practices. Don't use them in serious code.</p>

<h2>Each type parameter is a distinct named type and its underlying type is an interface type</h2>

<p>Since Go 1.18, named types include</p>

<ul>
<li>predeclared types, such as <code>int</code>, <code>bool</code> and <code>string</code>.</li>
<li>defined non-generic types.</li>
<li>instantiated types of generic types.</li>
<li>type parameter types (the types declared in type parameter lists).</li>
</ul>

<p>Two different type parameters are never identical.</p>

<p>The type of a type parameter is a constraint, a.k.a an interface type.
This means the underlying type of a type parameter type is an interface type.
However, this doesn't mean a type parameter behaves like an interface type.
Its values may not box non-interface values and be type asserted (as of Go 1.18).</p>

<p>In fact, a type parameter is just a placeholder for the types in its type set.
So it generally behaves as (the common traits of) the types in its type set in many situations.</p>

<p>As the underlying type of a type parameter type is not the type parameter type itself,
the tilde form <code>~T</code> is illegal if <code>T</code> is type parameter.
So the following type parameter list is illegal.
Because, as mentioned above, the type in a tilde form mustn't be an interface type
and its underlying type must be itself. Here the both of the conditions are not satisfied.</p>

<pre><code class="language-Go">[A int, B ~A] // error
</code></pre>

<p>For the same reason, the following generic type declaration is also illegal.</p>

<pre><code class="language-Go">type C[T int] interface {
	~T // error: cannot embed a type parameter
}
</code></pre>

<h2>Composite type literals containing type parameters are ordinary types</h2>

<p>For example, <code>*T</code> is always an ordinary (pointer) type.
It is a type literal, so its underlying type is itself, whether or not <code>T</code> is a type parameter.
The following type parameter list is legal.</p>

<pre><code class="language-Go">[A int, B *A] // okay
</code></pre>

<p>For the same reason, the following type parameter lists are also legal.</p>

<pre><code class="language-Go">[T ~string|~int, A ~[2]T, B ~chan T]            // okay
[T comparable, M ~map[T]int32, F ~func(T) bool] // okay
</code></pre>

<h2 id="type-parameter-scope">The scopes of a type parameters</h2>

<p>The following type parameter list is valid, even if the use of <code>E</code> is ahead of the declaration of <code>E</code>.
The type parameter <code>E</code> is used in the constraint of the type parameter <code>S</code>,</p>

<pre><code class="language-Go">[S ~[]E, E int]
</code></pre>

<p>Please note,</p>

<ul>
<li>as mentioned in the last section, although <code>E</code> is a type parameter type, <code>[]E</code> is an ordinary (slice) type.</li>
<li>the underlying type of <code>S</code> is <code>interface{~[]E}</code>, not <code>[]E</code>.</li>
<li>the underlying type of <code>E</code> is <code>interface{int}</code>, not <code>int</code>.</li>
</ul>

<p>For ordinary function and method declarations, a (value) parameter/result name
is allowed to be the same as a parameter/result type name.
For example, the following function and method declarations are all valid.</p>

<pre><code class="language-Go">type C int

func foo(C C) {}

func (C C) Bar() {}
</code></pre>

<p>The scope of a type parameter of a generic function or a method of a generic type
also include the function/method body and value parameter/result lists.
Simply speaking, type parameters and value parameters/results are all declared in
the top block of the function/method body.</p>

<p>This means the generic function declarations and method declarations for generic types
in the following code snippet all fail to compile (as of Go 1.18).</p>

<pre><code class="language-Go">type C any
func foo1[C C]() {}    // error: C redeclared
func foo2[T C](T T) {} // error: T redeclared

type G[G any] struct{x G} // okay
func (E G[E]) Bar1() {}   // error: E redeclared
func (v G[G]) Bar2() {}   // error: G is not a generic type
</code></pre>

<p>The <code>Bar2</code> method declaraiton might become legal
<a href="https://github.com/golang/go/issues/51503">since a future Go version</a>.</p>

<h2>Generic type/function instantiations</h2>

<p>Generic types must be instantiated to be used as types of values, and
generic functions must be instantiated to be called or used as function values.</p>

<p>A generic function (type) is instantiated by substituting a type argument list
for the type parameter list of its declaration (specification).
The lengths of the type argument is the same as the type parameter list.
Each type argument is passed to the corresponding type parameter.
A type argument must be a non-interface type or a basic interface type
and it is valid only if
it satisfies the constraint of its corresponding type parameter.</p>

<p>Instantiated functions are non-generic functions.
Instantiated types are named value types.</p>

<p>Same as type parameter lists, a type argument list is also enclosed in square brackets
and type arguments are also comma-seperated in the type argument list.
The comma insertion rule for type argument lists is also the same as type parameter lists.</p>

<p>Two type argument lists are identical if their lengths are equal and all of their corresponding types are identical.
Two instantiated types are identical if they are instantiated from the same generic type and with the same type argument list.</p>

<p>In the following program, the generic type <code>Data</code> is instantiated four times.
Three of the four instantiations have the same type argument list
(please note that the predeclared <code>byte</code> is an alais of the predeclared <code>uint8</code> type).
So the type of variable <code>x</code>, the type denoted by alias <code>Z</code>, and the underlying type of
the defined type <code>W</code> are the same type.</p>

<pre><code class="language-Go">package main

import (
	&quot;fmt&quot;	
	&quot;reflect&quot;
)

type Data[A int64 | int32, B byte | bool, C comparable] struct {
	a A
	b B
	c C
}

var x = Data[int64, byte, [8]byte]{1&lt;&lt;62, 255, [8]byte{}}
type Y = Data[int32, bool, string]
type Z = Data[int64, uint8, [8]uint8]
type W Data[int64, byte, [8]byte]

// The following line fails to compile because
// []uint8 doesn't satisfy the comparable constraint.
// type T = Data[int64, uint8, []uint8] // error

func main() {
	println(reflect.TypeOf(x) == reflect.TypeOf(Z{})) // true
	println(reflect.TypeOf(x) == reflect.TypeOf(Y{})) // false
	fmt.Printf(&quot;%T\n&quot;, x)   // main.Data[int64,uint8,[8]uint8]
	fmt.Printf(&quot;%T\n&quot;, Z{}) // main.Data[int64,uint8,[8]uint8]
}
</code></pre>

<p>Basic interface types may be used as type arguments,
as long as they implement the constraints of their corresponding type parameters.
For example, the following code compiles okay.</p>

<pre><code class="language-Go">package main

func cot[T any](x T) {}

func main() {
	cot(123)
	cot(true)
	
	var x, y interface{} = 123, true
	cot(x) // okay
	cot(y) // okay
}
</code></pre>

<p>The following is an example using some instantiated functions
of a generic function.</p>

<pre><code class="language-Go">package main

type Ordered interface {
	~int | ~uint | ~int8 | ~uint8 | ~int16 | ~uint16 |
	~int32 | ~uint32 | ~int64 | ~uint64 | ~uintptr |
	~float32 | ~float64 | ~string
}

func Max[S ~[]E, E Ordered](vs S) E {
	if len(vs) == 0 {
		panic(&quot;no elements&quot;)
	}
	
	var r = vs[0]
	for i := range vs[1:] {
		if vs[i] &gt; r {
			r = vs[i]
		}
	}
	return r
}

type Age int
var ages = []Age{99, 12, 55, 67, 32, 3}

var langs = []string {&quot;C&quot;, &quot;Go&quot;, &quot;C++&quot;}

func main() {
	var maxAge = Max[[]Age, Age]
	println(maxAge(ages)) // 99
	
	var maxStr = Max[[]string, string]
	println(maxStr(langs)) // Go
}
</code></pre>

<p>In the above example, the generic function <code>Max</code> is instantiated twice.</p>

<ul>
<li>The first instantiation <code>Max[[]Age, Age]</code> results a <code>func([]Age] Age</code> function value.</li>
<li>The second one, <code>Max[[]string, string]</code>, results a <code>func([]string) string</code> function value.</li>
</ul>

<h2>Type argument inferences for generic function instantiations</h2>

<p>In the generic function example shown in the last section,
the two function instantiations are calle full form instantiations,
in which all type arguments are presented in their containing type argument lists.
Go supports type inferences for generic function instantiations,
which means a type argument list may be partial or even be omitted totally,
as long as the missing type arguments could be inferred from value parameters
and present type arguments.</p>

<p>For example, the <code>main</code> function of the last example in the last section could be rewritten as</p>

<pre><code class="language-Go">func main() {
	var maxAge = Max[[]Age] // partial argument list
	println(maxAge(ages)) // 99
	
	var maxStr = Max[[]string] // partial argument list
	println(maxStr(langs)) // Go
}
</code></pre>

<p>A partial type argument list must be a prefix of the full argument list.
In the above code, the second arguments are both omitted,
because they could be inferred from the first ones.</p>

<p>If an instantiated function is called directly and some suffix type arguments
could be inferred from the value argument types, then the type argument list
could be also partial or even be omitted totally.
For example, the <code>main</code> function could be also rewritten as</p>

<pre><code class="language-Go">func main() {
	println(Max(ages))  // 99
	println(Max(langs)) // Go
}
</code></pre>

<p>The new implementation of the <code>main</code> function shows that the calls of
generics functions could be as clean as ordinary functions (at least sometimes),
even if generics function declarations are more verbose.</p>

<p>Please note that, type argument lists may be omitted totally but may not be blank.
The following code is illegal.</p>

<pre><code class="language-Go">func main() {
	println(Max[](ages))  // syntax error
	println(Max[](langs)) // syntax error
}
</code></pre>

<p>The inferred type arguments in a type argument list must be a suffix of the type argument list.
For example, the following code fails to compile.</p>

<pre><code class="language-Go">package main

func foo[A, B, C any](v B) {}

func main() {
	// error: cannot use _ as value or type
	foo[int, _, bool](&quot;Go&quot;)
}
</code></pre>

<p>Type arguments could be inferred from element types, field types,
parameter types and result types of value argument types.
For example,</p>

<pre><code class="language-Go">package main

func luk[E any](v struct{x E}) {}
func kit[E any](v []E) {} 
func wet[E any](v func() E) {}

func main() {
	luk(struct{x int}{123})        // okay
	kit([]string{&quot;go&quot;, &quot;c&quot;})       // okay
	wet(func() bool {return true}) // okay
}
</code></pre>

<p>If the type set of the constraint of a type parameter contains only one type
and the type parameter is used as a value parameter type in a generic function,
then compilers will attempt to infer the type of an untyped value argument
passed to the value parameter as that only one type. If the attempt fails,
then that untyped value argument is viewed as invalid.</p>

<p>For example, in the following program, only the first function call compiles.</p>

<pre><code class="language-Go">package main

func foo[T int](x T) {}
func bar[T ~int](x T) {}

func main() {
	// The default type of 1.0 is float64.

	foo(1.0)  // okay
	foo(1.23) // error: cannot use 1.23 as int

	bar(1.0) // error: float64 does not implement ~int
	bar(1.2) // error: float64 does not implement ~int
}
</code></pre>

<p>Sometimes, the inference process might be more complicate.
For example, the following code compiles okay.
The type of the instantiated function is <code>func([]Ints, Ints)</code>.
A <code>[]int</code> value argument is <a href="https://go101.org/article/value-conversions-assignments-and-comparisons.html">allowed to be passed</a> to an <code>Ints</code> value parameter,
which is why the code compiles okay.</p>

<pre><code class="language-Go">func pat[P ~[]T, T any](x P, y T) bool { return true }

type Ints []int
var vs = []Ints{}
var v = []int{}

var _ = pat[[]Ints, Ints](vs, v) // okay
</code></pre>

<p>But both of the following two calls don't compile.
The reason is the missing type arguments are inferred from value arguments,
so the second type arguments are inferred as <code>[]int</code>
and the first type arguments are (or are inferred as) <code>[]Ints</code>.
The two type arguments together don't satisfy the type parameter list.</p>

<pre><code class="language-Go">// error: []Ints does not implement ~[][]int
var _ = pat[[]Ints](vs, v)
var _ = pat(vs, v)
</code></pre>

<p>Please read Go specification for <a href="https://go.dev/ref/spec#Type_inference">the detailed type argument inference rules</a>.</p>

<h2>Restrictions of type argument inferences</h2>

<p>Currrenly (Go 1.18), inferring type arguments of instantiated types from value literals is not supported. That means the type argument list in a generic type instantiation must be always in full forms.</p>

<p>For example, in the following code snippet, the declaration line for variable <code>y</code> is invalid,
even if it is possible to infer the type argument as <code>int16</code>.</p>

<pre><code class="language-Go">type Set[E comparable] map[E]bool

// compiles okay
var x = Set[int16]{123: false, 789: true}

// error: cannot use generic type without instantiation.
var y = Set{int16(123): false, int16(789): true}
</code></pre>

<p>Another example:</p>

<pre><code class="language-Go">import &quot;sync&quot;

type Lockable[T any] struct {
	sync.Mutex
	Data T
}

// compiles okay
var a = Lockable[float64]{Data: 1.23}

// error: cannot use generic type without instantiation
var b = Lockable{Data: float64(1.23)}
</code></pre>

<p>It is not clear whether or not <a href="https://github.com/golang/go/issues/50482">type argument inferences
for generic type instantiations</a>
will be supported in future Go versions.</p>

<p>Currently (Go toolchain 1.18), there is still improvement room for the current type argument inference implementation of the standard Go compiler.
For example, the following program fails to compile.</p>

<pre><code class="language-Go">package main

type Getter[T any] interface {
	Get() T
}

type Age[T uint8 | int16] struct {
	n T
}

func (a Age[T]) Get() T {
	return a.n
}

func handle[T any](g Getter[T]) {}

func main() {
	var age = Age[int16]{256}

	// error: type Age[int16] of age does not
	//        match Getter[T] (cannot infer T)
	handle(age)
	
	// This verbose way works.
	var x Getter[int16] = age
	handle(x) // okay
}
</code></pre>

<p>The above program <a href="https://github.com/golang/go/issues/41176">might compile okay</a>
by using a future version of the standard Go compiler.</p>
